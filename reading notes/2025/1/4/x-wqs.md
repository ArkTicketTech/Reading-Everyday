两类公钥加密系统，一种是建立在陷门函数上，尤其是RSA，另外一种是建立在DH协议上。其实他们都遵循一个统一的原则。即：单向函数。

One way functions 
A function f: X → Y is one way if  从集合X到集合Y是单向的，当存在一个算法来计算F，任何人可以根据需要F在某个点的值，但计算F的逆函数就很难。这就使它成为了单向函数。

X中的很多点可以计算出Y中的同一点，当我给你了Y中的某一点，你很难找到这些点中的任何一个。没有有效的算法可以找到Y中一个给定的点的原象。

对于所有有效的算法A，如果我们从集合X中任选一个x，并将f(x)赋值给算法A，让A找到f(x)的原象，的概率是可以忽略的。

证明单向函数存在，实际上相当于证明P = NP，由于我们无法证明P = NP，所以我们无法证明单向函数一定存在。

# 单向函数的例子

函数f，集合X映射到集合Y，|Y| 输出长度比 |X|输入长度大的多，一个伪随机数生成器使用一个很小的种子，将它拓展成为一个大得多的输出，比如这个伪随机数生成器是用了确定性计数器 AES构造。不难看出，如果F是一个可靠的伪随机数生成器，那么F实际上是一个单向函数。

假设有一个计算F的逆的有效算法A，假设F不是单向函数，A是计算F的逆的有效算法。
B(y) = 1,  1 otherwise
B(y) = 0, f(A(y)) = y, output 0
如果y是PRG输出的，那么大概率输出0；如果y是真的随机字符串，我们难以找到这样的种子，所以大概率会输出1。

观察所有可能的输出Y，其实只有很少一部分是PRG输出的值，所以如果随便给定某个输出y，y不属于PRG输出集合，当应用算法A时，不可能输出它的种子。因为大多数的点都不属于PRG的输出集合，也就没有一个让生成器将其映射到它自己的种子。
