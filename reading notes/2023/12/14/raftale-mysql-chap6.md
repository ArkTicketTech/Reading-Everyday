这一章将详细介绍InnoDB存储引擎对表中数据的锁定，同时分析InnoDB存储引擎会以怎样的粒度锁定数据。

# 什么是锁

锁机制用于管理对共享资源的并发访问。

InnoDB存储引擎会在行级别上对表数据上锁，也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素。

InnoDB存储引擎锁的实现和Oracle数据库非常类似，提供 一致性的非锁定读（就是快照读）、行级锁支持。

# lock与latch

lat ch 一般称为闩锁 (轻量级的锁)，因为其要求锁定的时间必须非常短。若持续的 时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex (互斥量)和rwlock (读写锁)。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。

lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit 或rollback 后进行释放。lock有死锁检查机制。

对于InnoDB存储引擎中的latch，可以通过命令`SHOW ENGINE INNODB MUTEX`来进行查看。

# InnoDB存储引擎中的锁

## 锁的类型

InnoDB实现了两种级别的行级锁：

1. 共享锁(SLock)，允许事务读 一行数据。
2. 排他锁(XLock)，允许事务删除或更新 一行数据。

跟读写锁几乎是相同的，当作读写锁就行。

InnoDB存储引擎支持多粒度(granular)锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。

### 意向锁

为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁 (Intention Lock)。

意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度(fine granularity)上进行加锁，如下图所示。

1. 意向共享锁 (ISLock)，事务想要获得一张表中某几行的共享锁
2. 意向排他锁 (IXLock)，事务想要获得 一张表中某几行的排他锁

意向锁要解决的问题是：

1. MySQL有表锁，InnoDB支持行锁，两种锁可能会冲突，比如行锁加了读锁，但另一个事务又申请表的写锁；
2. 如果没有意向锁，加粗粒度的表锁时就需要遍历整个表是否有行锁冲突
3. 意向锁的出现简化了判断逻辑，加行锁之前加意向锁，下一个事务通过判断意向锁来判断是否有冲突。


## 一致性非锁定读

如果读取的行正在执行DELETE和UPDATE操作，那么读取操作不会因此去等待行上锁的释放，而是去读取行的一个快照数据。

这是多版本控制（MVCC）的实现。

读快照数据是通过undo段来完成的，而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。

只有开启了读已提交和可重复读，才能使用快照，解决了脏读的问题。



每行记录不止有一个快照数据。

1. 读已提交：总是读取被锁定行的最新一份快照数据，只解决脏读，但会有不可重复读的问题。
2. 可重复读：总是读取该事务开始时的行数据版本，保证可重复读。

## 一致性锁定度

显式的对数据库的读取加锁。

支持一致性锁定读操作

1. select ... for update：给读取的行记录加了一个排他锁
2. select ... lock in share mode：给读取的行记录加了一个共享锁

这个看起来其实就写读写锁，读锁不阻塞读，但阻塞写；而写锁阻塞读和写。

事务提交了，锁才能释放。

## 自增长与锁

自增主键是通过自增长计数器实现的，当对含有自增主键的表进行插入操作时，这个计数器就会被初始化，执行如下的语句来得到当前计数器的最大值。

```sql
select max(auto_inc_col) from t for update 
```

上面说到，for update相当于加了一个排他锁X，阻塞其他线程读写。

插入操作拿到这个最大值后，然后加1赋予自增长列，这个实现方式叫做Auto-Inc Locking，这个锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增值插入的SQL语句后立即释放。

但Auto-Inc Locking还是存在性能问题：

1. 并发时必须等待锁的释放
2. 对于insert... select的大数据的插入，会影响插入的性能，因为当前语句还没有完成，另一个事务的插入会被阻塞

MySQL5.1.22版本提供了一种轻量级互斥量的自增长实现机制，提高了自增长值增长的性能：







自增长插入的分类：

1. insert-like：所有的插入语句
2. simple inserts：插入前就确定行数的语句。
3. bulk inserts：插入前不能确定得到插入语句的行数，如insert...select
4. mixed-mode inserts：部分确定，部分不确定，如insert ... on duplicate key update

```
show variables like '%innodb_autoinc_lock_mode'
```
