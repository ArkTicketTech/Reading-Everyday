索引太多，插入性能会受到影响；但索引太少，查询性能也会受到影响。要找到一个合适的平衡点。

# InnoDB存储引擎索引概述

InnoDB支持的索引：

1. B+树索引
2. 全文索引
3. 哈希索引

哈希索引前面提到过是自适应的，会自动生成。

B+树就是一颗平衡查找树，B+树索引并不能找到一个给定key的具体行，只能找到数据行所在的页。然后数据库把页加载到内存，再到内存中进行查找，最后得到要查找的数据。

# 数据结构与算法

1. 二分查找：每页Page Directory中的槽是按照主键的顺序存放的，对于某一条具体记录的查询是通过对Page Directory进行二分查找得到的；
2. 二叉查找树和平衡查找树：修改平衡树需要左旋或右旋。



# B+树和B+树索引

B+树不再解释了，算法有专门的章节，它的特点是高扇出性（fan out)，扇出是指每个结点指向子结点的指针个数。

B+树的高度一般都在2～4层，也就是查找某一键值的行记录时最多只需要2到4次IO。一般的机械硬盘每秒至少可以做100次IO，2～4次大约0.02～0.04秒。

数据库中的B+树可以分为聚集索引（Clustered Index）和辅助索引（secondary index）。

两者的区别是Clustered Index的叶子结点存放的是一整行的信息。

1. 聚簇索引（Clustered index）

1. 聚簇索引就是主键构成的B+树，叶子结点存放的即为整张表的行记录数据，聚簇索引的叶子结点也称为数据页。
2. 聚簇索引在物理上并不是连续的。

1. 二级索引（Secondary Index)：

## B+树索引的分裂

B+树索引页的分裂并不总是从页的中间开始的，这样可能导致页空间的浪费。

InnoDB会采用一些优化来决定分裂点。

## B+树索引的管理

### 索引管理

```
show index from t
```

其中的参数



添加索引和删除索引这类的DDL操作过程：

1. 首先创建一张新的临时表；
2. 然后把原表中数据导入临时表；
3. 接着删除原表
4. 最后把临时表重命名为原来的表名



Fast Index Creation：

1. 创建索引加上一个S锁，即共享锁，只可读不可写
2. 会阻塞写，数据服务仍然不可用
3. 不需要重建表，因此速度很快





## Cardinality

索引列需要有区分度

怎么判断索引有区分区度？

`show index`看列cardinality，它表示索引不重复记录数量的预估值。

Cardinality是放在存储引擎层进行的。

统计都是通过采样进行的，采样策略：

1. 表中1/16的数据已经发生过变化
2. 记录变化的次数stat_modified_counter > 2000 000 000



# B+树索引的使用

## 联合索引

联合索引也是一颗B+树，不同的是它的键值的数量是索引字段的个数。



## 覆盖索引

covering index，即从辅助索引中就可以得到查询到记录，就不需要再去查询聚簇索引中的记录。



## 强制索引

force index

## 索引提示

MySQL数据库支持索引提示（Index HINT），显式地告诉优化器使用哪个索引。

USE INDEX

与force index的区别是前者只是告诉优化器可以选择该索引，实际上优化器还是会再根据自己的判断，而后者是强行走指定索引的。



## Multi-Range Read优化

MRR优化的目的是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问。

启用了MRR优化，优化器会先将查询条件进行拆分，然后再进行数据查询。

```sql
select * from t where key1 >= 1000 and key1 < 2000 and key2 = 10000
```

表t有(key1, key2)的联合索引，但因为key1是范围查询，无法充分利用联合索引，如果没有MRR，优化器会先将key1在1000到2000的数据都取出，然后筛选key2。

如果启用MRR，查询条件会被拆分为(1000, 10000), (1001, 10000), ...，直接走联合索引

## Index Condition Pushdown（ICP）优化

索引下推，能从索引中获取到的信息，就从索引中获取。

## 哈希

知道某个页，如何快速找到它，就要用到哈希。

InnoDB的表空间都有一个space_id，用户要查询的应该是某个表空间某个连续的16KB的页，即偏移量offset。

key就是space_id和offset，value就是页。

## 全文索引

看es吧
