# 构建去中心化的货币系统


我们假设央行要发行数字货币，很直观的是参考现金的发行形式，现金的特征是：

1. 防伪标记： 难以伪造，不可篡改
2. 唯一性：无法复制



如果要实现数字货币的防伪标记，那么基于公私钥体系就能很容易的实现，发行100元需要通过央行的私钥进行签名，公钥是公开的，任何人都可以验证它的权威性。公私钥保证了不可篡改，但没有解决货币的唯一性，毕竟代码本身就是文件，是可以无限复制的。



如果数字货币可以无限复制，就容易产生双花攻击，即被央行发行的一个货币被多次花费。



防止双花攻击的一个中心化的解决方法是: 给每个发行的货币增加一个唯一标识码，再记录该货币在谁手上。每一次交易都需要央行确认。这个方法可以叫做记账法。



中心化记账法的问题是：任何交易都要通过央行确认合法性，但中心化系统会面临一些问题，可能有：

1. 央行控制者滥发货币；
2. 央行的数据库容易被攻击篡改；
3. 交易确认造成的高负载；
4. 单点故障；



如果要构建一个去中心化的货币系统，那么急需解决两个问题：

1. 谁有权利发行货币？
    1. 挖矿
2. 如何验证交易的有效性: 也是如何防止双花？



比特币的每个交易都包含了输入、输出和「签名」。

1. 输入部分包含了 币的来源和转账方的公钥哈希。
2. 输出部分包含了 收款人的公钥哈希。
3. 签名：私钥对交易的签名



一个转账的例子：



                   ┌───────────┐    ┌──────────────┐     ┌─────────────┐              
                   │           │    │              │     │             │              
     ┌─────────────┼────┐     ┌┼────▼──────┐     ┌─┼─────▼──────┐    ┌─┼────────────┐ 
     │ create coin │    │     │A┌──►B(5)   │     │ B┌───►C(2)   │    │ C────►E(7)   │ 
     │             ▼    │     │ │          │     │  │           │    │ │            │ 
     │       ─────►A(10)│◄────┤ │          │◄────┤  │           │◄───┤ │            │ 
     │                  │     │ └──►C(5)   │     │  └───►D(3)   │    │ │            │ 
     │                  │     │ signed by A│     │  signed by B │    │ │signed by C │ 
     └──────────────────┘     └─────▲──────┘     └──────────────┘    └─┼────────────┘ 
                                    │                                  │              
                                    │                                  │              
                                    └──────────────────────────────────┘              





输入部分说明币的来源很重要，因为它可以解决双花问题：如果在最后，B 又转给F账户（公钥的转换）5个coin，但实际上B已经在第二个交易中花费完了，再次转账就无法成功。



A 转给B的交易中，输入部分包含了A的公钥哈希，它被用来验证签名，但公钥哈希和交易的签名是可以伪造的，所以A的公钥哈希必须要与币的来源中的收款方的公钥哈希匹配。

> 这里产生了一个疑问，如果有人恶意的去匹配A的公钥哈希和签名，那不就可以匹配上了吗？
>
> 我的猜测：签名是无法伪造的，因为A是用私钥对整体交易进行了加密，也就是如果你想变动交易中的信息，签名就对不上；如果是全部复制一模一样的交易，但上面说到这种区块链设计又避免了双花攻击，所以全部复制也就没有了意义。



# 实际系统的扩展



实际系统中每个区块包含了很多交易，区块又分成了block header和block body，签名只是针对于block header，header中的merkle root hash指向block body，block body中的交易组织成了merkle tree，保证了交易不可篡改的特性。

```
                                       
  ┌───────┐◄───┬───────┐◄────┬───────┐   
  │header │    │header │     │header │   
  └───┬───┘    └───┬───┘     └───┬───┘   
      ▼            ▼             ▼       
  ┌───────┐    ┌───────┐     ┌───────┐   
  │ body  │    │ body  │     │ body  │   
  │       │    │       │     │       │   
  │       │    │       │     │       │   
  └───────┘    └───────┘     └───────┘   
```



区块具体包含

1. block header：
    1. revesion
    2. hash of previous block header
    3. merkle root hash: 保证了body中的交易是无法篡改的
    4. target: H() <= target
    5. nonce
2. blocker body：存储了交易列表，这些交易又组织成了merkle tree。header中持有的merkle root hash保证了交易不可篡改的形状



1. full node: full validating node
2. light node: only including block header
