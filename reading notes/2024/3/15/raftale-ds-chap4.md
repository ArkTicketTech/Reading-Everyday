## 故障屏蔽

既然无法在异步系统中达成共识，那么我们可以想办法将异步系统转换为同步系统。

故障屏蔽就是第一种转换方法。

假设故障的进程最终会恢复，并找到一种重新加入分布式系统的方式，如果没有收到来自某个进程的消息，就一直等待，直到收到预期的消息。

常见的一种方法是，如果一个进程崩溃，那么它会被重启，进程在持久化存储中保留了足够多的信息，以便在崩溃和重启时能够利用这些数据继续工作。换句话说，故障的进程也能够像正确的进程一样工作，只是它有时候需要很长时间执行一个恢复处理，例如，在两阶段提交协议中使用了持久化存储，让进程能够从故障中重新恢复状态。

## 故障检测器

故障检测器是第二种转换方法。

进程可以通过某种故障检测器来确认没有响应的进程是否已经发生故障。

一种最常见的故障检测器是超时故障检测器，如果进程在一定时间内没有响应，那么即使该进程没有发生故障，也认为该进程已经失效。

## 使用随机性算法

随机性算法使得「敌人」不能有效地阻碍系统达成共识，即实现拜占庭容错。

常见的应用如比特币这类的区块链。

## 同步系统中的共识

同步系统中实现共识算法是有理论支持的。

Dolev-Strong算法证明了：在同步系统中，有不超过f个进程发生故障，且错误进程数量小于总进程N，那么经过f+1轮消息传递后即可达成共识。

大多数企业生产环境的共识算法，都依赖于部分同步系统的假设。

本章将着重讨论同步系统中的共识。

1. 非拜占庭容错：Paxos和Raft算法
2. 拜占庭容错：PBFT

# Paxos

有些内容不是在书中讲解的，有参考

https://hardcore.feishu.cn/docs/doccnucpEur2hvGGVRtFshRWx0D



1. Paxos是一系列共识算法。
2. 是由Lamport提出的。
3. 非拜占庭问题。



Paxos用提案来推动整个算法，使系统决议出同一个提案，提案包括提案编号和提案值。各个节点需要通过消息传递不断提出提案，最终整个系统接受同一个提案，进入一个一致的状态，即对某个提案达成共识。如果集群中超过半数的节点接受该提案，那么提案被批准。在Basic-Paxos中，**一旦某个提案被批准，提议者都必须将该值作为后续提案值**。



Paxos算法的角色分为：

1. 客户端：发送请求
2. 提议者(Proposer)：收到客户端的请求，提出相关的提案；
3. 投票者（Voters/Acceptors）：投票接受或者拒绝提议者的提案，若超过半数的接受者接受提案，则该提案被批准
4. 学习者(Learner)：学习被批准的提案，不参与决议提案，能够响应客户端。

## 问题描述

我们讨论的Basic-Paxos只会批准一个提案值，因此需要设计一个两阶段协议，将已经批准的值告知后续的请求，让后续的提案也使用相同的值。



## 算法实现流程

Basic Paxos只决议出一个共识的值。

算法主要包括两个阶段。

1. 第一阶段：

    1. Prepare 阶段：提议者广播prepare消息，请求接受者对提案编号进行投票

    1. Promise 阶段：接受者收到prepare请求消息后进行响应
        1. 如果Prepare消息中的提案编号n大于之前的所有提案编号，则返回promise消息进行响应，并承诺不会再接受任何编号小于n的提案。否则忽略该请求

2. 第二阶段：

    1. Accept/Propose阶段：当提议者收到超过半数的接受者的Promise()响应后，提议者向多数派的接受者发起accept(n, value)请求，这次要带上提案编号和提案值。

    1. Accepted 阶段：接受者收到Accept()请求后，在这期间如果接受者没有另外承诺提案编号比n更大的提案，则接受该提案，更新承诺的提案编号，保存已接受的提案。

## 活锁

Basic Paxos存在活锁问题，提议者A在第一阶段发送Prepare请求消息，还没来得及发送第二阶段的Accept请求消息，紧接着第二个提议者B又在第一阶段又发出提案编号更大的Prepare请求，那么提议者A的第二个阶段的Accept会被拒绝，拒绝后如果又产生重试，新的Prepare消息又在提议者B的Accept之前，导致提议者B的Accept也被拒绝，也就是说有可能出现一直有提案，但没有一个提案可以达成。
