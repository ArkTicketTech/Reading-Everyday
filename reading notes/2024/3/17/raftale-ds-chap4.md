## 日志复制

Raft中日志格式为：

1. 索引Index：索引表示该日志条目在整个日志中的位置
2. 任期号：日志条目首次被领导者创建的任期
3. 命令：应用于状态机的命令

日志必须持久化存储，一个节点必须先将日志条目安全写到磁盘中，才能向系统中其他节点发送请求或者回复请求。

如果一条日志被存储在超过半数的节点上，则认为该记录已提交。



Raft算法正常运行时，日志复制的流程为：

1. 客户端向领导者发送命令，希望该命令被所有状态机执行；
2. 领导者先将该命令追加到自己的日志中，确保日志持久化存储；
3. 领导者并行地向其他节点发送AppendEntries消息，等待响应；
4. 跟随者将请求的日志项追加到自己的本地日志中，并将结果返回给领导者；
5. 领导者如果收到超过半数节点的响应，领导者则认为新的日志记录**已提交**，接着领导者将命令应用到自己的状态机，然后向客户端返回响应；

1. 此时日志记录已经被提交，所以后续的AppendEntries会将这个信息传递给跟随者，跟随者也会提交该日志记录，并应用到状态机上；
2. 这里的创新点在于，领导者并没有等待跟随者也将日志应用到状态机后再返回给客户端，对客户端来说，相当于是一阶段提交了，提高了效率

1. 如果跟随者宕机或者请求超时，日志没有成功复制，那么领导者将反复尝试发送AppendEntries消息。



Raft和Paxos不同之处在于Raft的日志必须连续地提交。

索引和任期号唯一标识了一个日志条目，为了保证安全性，Raft会进行一致性检查。

一致性检查：每个AppendEntries消息请求包含新日志条目之前一个日志条目的索引（prevLogIndex）和任期（prevLogTerm），跟随者收到请求后，会检查自己最后一条日志的索引和任期号是否与请求消息中的prevLogIndex和prevLogTerm相匹配，如果匹配则接受该记录，否则拒绝。

## 领导者更替



## 选举限制举例



## 延迟提交之前任期的日志条目



## 清理不一致的日志



## 处理旧领导者

任期可以用来避免脑裂问题，

1. 每个RPC请求都包含发送方的任期
2. 如果接收方发现发送方的任期陈旧，无论哪个过程，该RPC请求都会被拒绝。并且发送方会转变为跟随者。

## 客户端协议

Raft算法要求必须由领导者来处理客户端请求。

领导者会通过请求的唯一ID对请求进行幂等处理。

## 实现线性一致性



## 配置变更

 

## 配置变更存在的Bug
 

## 极端情况下的活性问题
 

## 日志压缩

## 基于内存的状态机的快照


## 基于磁盘的状态机的快照
 

## 性能优化



# Raft Vs Paxos

共同点：

1. 从给所有节点中选出一个领导者，它接受所有的写操作，并将日志发送给跟随者
2. 多数派复制了日志后，该日志提交，所有成员最终会将该日志中的命令应用于它们的状态机。
3. 如果领导者失败了，则多数派会选出一个新的领导者
4. 两者都满足状态机安全性和领导完整性。



Raft比Paxos的好处在于三点：

1. 表现形式：Raft可理解性更强，更实用
2. 简单性：Raft按顺序提交日志；Raft中的所有日志的副本都有相同的索引、任期和命令
3. 高效的领导者选举算法：Raft总能选出拥有多数派日志的节点，不需要追赶日志。



细节太多，有精力在看
