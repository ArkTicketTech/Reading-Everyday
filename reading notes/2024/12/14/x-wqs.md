# 消息认证码（MAC）概述
## 引言
在本模块中，我们将不再讨论加密，而是转向消息完整性的讨论。我们的目标是在不考虑保密性的情况下提供完整性。
## 现实应用场景
在现实世界中，有许多只需要完整性而不需要保密性的应用场景：
1. **操作系统文件**
   - Windows系统文件本身并不保密
   - 但需要防止被病毒或恶意软件修改
2. **网页广告**
   - 广告商不在意广告内容被复制
   - 但需要防止广告内容被篡改
如何保证消息的完整性？使用MAC（message authentication code）。
## MAC的基本机制
### 工作原理
1. Alice和Bob共享一个密钥K（对攻击者保密）
2. Alice要发送公开消息M给Bob
3. Alice使用MAC签名算法S(K,M)生成短标签（约90-100位）
4. Alice将消息和标签一起发送给Bob
5. Bob使用MAC验证算法验证消息完整性
### MAC的定义
MAC由两个算法组成：
- **签名算法**：S(k,m) → t ∈ T，其中t是标签空间T中的标签
- **验证算法**：V(k,m,t) → {yes,no}，验证消息-标签对的有效性
### 一致性要求
对于密钥空间中的每个K和消息空间中的每个消息：
- 用同一密钥进行签名和验证应得到"是"的回应
## 为什么需要共享密钥
### CRC的反面教材
- CRC（循环冗余校验）是无密钥的校验和算法
- 设计用于检测随机错误，而非恶意修改
- 攻击者可以：
  1. 拦截Alice的消息和标签
  2. 生成新消息M'
  3. 计算新的CRC
  4. 发送给Bob
- Bob收到后会验证tag == CRC(M')，由于CRC是公开的算法，攻击者生成的新CRC可以通过验证，会认为来自Alice
### 密钥的重要性
- 没有密钥，Bob无法区分Alice和攻击者
- 密钥使Alice可以执行攻击者无法完成的操作，计算出攻击者无法修改的标签 
- CRC只适用于随机错误检测，不适用于防御恶意攻击
## MAC的安全性定义
### 攻击者能力：选择消息攻击(chosen message attack)
- 可以选择消息m1到mq给Alice
- Alice计算这些消息的标签
- 攻击者获得标签
### 现实世界的选择消息攻击示例
- 攻击者发送电子邮件给Alice
- Alice为邮件计算标签并存储
- 攻击者获取存储介质，得到标签
### 攻击者目标：存在性伪造(existential forgery)
- 产生新的有效消息-标签对
- 必须与选择消息攻击期间获得的对不同
- 即使是无意义消息的伪造也视为不安全
### 安全性的额外要求
- 攻击者不能为已知消息生成新标签
- 对于加密和完整性的组合很重要
## MAC的安全性游戏
### 游戏流程
MAC I=(S,V)安全性游戏包含以下步骤:
1. 挑战者(Chal.)随机选择MAC密钥 k ← K
2. 对手(Adv.)进行选择消息攻击（Q次）:
   - 对手选择消息 m1,...,mq ∈ M
   - 获得标签 ti ← S(k,mi)
3. 对手尝试存在性伪造,输出一个消息-标签对 (m,t)
### 胜利条件
对手输出的消息-标签对(m,t)必须满足:
1. V(k,m,t) = 'yes'  能通过验证
2. m ∉ {m1,...,mq}   与之前未见过
### 安全性定义
- 对手优势: Adv[A,I] = Pr[b=1]
  其中 b = 1 当且仅当:
  - V(k,m,t) = 'yes' 且 
  - (m,t) ∉ {(m1,t1),...,(mq,tq)}
  否则 b = 0
- 安全MAC: 对于所有高效对手A,Adv[MAC][A] ≤ ε(可忽略值)
## 重要安全考虑
### 标签碰撞问题
- 如果两个消息有相同标签的概率为1/2，则MAC不安全
- 攻击者可通过选择消息攻击利用这一点
### 标签长度问题
- 过短的标签（如5位）使MAC不安全
- 攻击者可以通过随机猜测成功
- 推荐标签长度：64位、96位或128位
## 实际应用：使用MAC保护系统文件
### 实现方式
1. 安装操作系统时：
   - 用户提供密码
   - 从密码中获取密钥K
   - 为每个系统文件计算标签
   - 存储文件和标签
   - 擦除密钥K
2. 验证时：
   - 从干净环境启动
   - 用户重新提供密码
   - 验证所有文件的MAC
### 注意事项
- 病毒无法创建带有效标签的新文件
- 需要将文件名包含在MAC计算中，防止文件交换攻击
