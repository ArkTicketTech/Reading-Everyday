# 死锁问题

什么是死锁：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的想象。

细粒度锁是有代价的，这个代价就是可能会导致死锁。

一个很好的死锁例子：

如果有客户找柜员张三做个转账业务：账户A 转账户B 100元，此时另一个客户找柜员李四也做个转账业务：账户B 转账户A 100 元，于是张三和李四同时都去文件架上拿账本，这时候有可能凑巧张三拿到了账本A，李四拿到了账本B。张三拿到账本A后就等着账本B（账本B已经被李四拿走），而李四拿到账本B后就等着账本A（账本A已经被张三拿走），他们要等多久呢？他们会永远等待下去…因为张三不会把账本A送回去，李四也不会把账本B送回去。

资源分配图可以用来可视化锁的占用情况（有向图），可以描述资源和线程的状态。

# 预防死锁

Coffman 总结以下四个条件都发生会发生死锁：

1. 互斥，共享资源X和Y只能被一个线程占用；
2. 占有且等待，线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；
3. 不可抢占，其他线程不能强行抢占线程T1占有的资源；
4. 循环等待，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。

破坏其中一个，就可以成功避免死锁。

有的时候思考计算机中一些问题的时候，可以联系现实问题来进行映射建模，易于理解。
