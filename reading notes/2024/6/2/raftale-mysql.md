锁
InnoDB支持行级锁，为了解决共享资源的并发问题。
行级锁类别：
1. 共享锁（SLock）
2. 排他锁（XLock）

相当于读写锁，允许多个读操作同时进行，但每次只允许一个写操作。

意向锁：为了解决MySQL的表锁和InnoDB的行锁冲突，比如行锁加了读锁，但是另一个事务又申请写锁。
原理就是将 数据库 -> 表 -> 页 -> 记录 看成层级关系，对某个结点加锁，需要对其所有上级进行加意向锁，一旦有某个结点已经被持有锁，那么再次加锁时就能识别出来。


一致性非锁定读：开启了读已提交及其以上的隔离级别，其实读操作就不需要再获取锁，而是读取的已经确定的数据，也就是快照。这样就大幅提高了读的性能。
实现原理就是MVCC。

一致性锁定读：支持用户显式的给读加锁。
1. select ... for update 排他锁，表明其他事务不能读写，必须等待锁释放。
2. select ... lock in share mode 共享锁，表明其他事务只可以读，不可以写。

行锁的三种算法：
1. Record Lock：单行记录锁
2. Gap Lock：范围锁（间隙锁），不包含记录本身
3. Next-Key Lock： Gap Lock + Record Lock

唯一索引查询时是Record Lock
二级非唯一索引是Next-Key Lock，Next-Key Lock的目的是为了解决幻读问题，
幻读问题是指：在同一事务下，连续执行两次相同的SQL查询可能导致不同的结果，第二次的结果可能因为其他事务的插入返回之前不存在的行。
范围查询时如果只对已有的记录加锁，就可能造成前后两次查询不一样。
不可重复读的隔离级别下才有next-key lock。
InnoDB解决幻读就是靠的Next-Key Lock和显式排他锁，既然是显式，其实也不算解决了幻读，这个看定义了。

锁问题：
1. 脏读
2. 不可重复读
3. 丢失更新


事务

ACID：
1. Atomicity: 
2. Consistency: 某种约束
3. isolation: 线程安全
4. durability: 

事务的默认保存点是事务开启时刻，可以显式设置保存点。

undo log用于事务回滚。
其原理时执行相反的语句。


group commit 的目的是提高刷盘（fsync）效率，将多个事务的redo log一起刷盘，但这与两阶段提交有冲突。
两阶段提交是为了保证redo log和binlog的原子性和一致性，因为binlog不是InnoDB的而是MySQL层面的，相当于并发操作可能导致两者落盘后顺序不一致，产生的后果是通过binlog进行备份时，先发生但尚未提交的事务会永久性的丢失。
所以两阶段提交和group commit 是冲突的。
为了解决这个问题，MySQL5.6提出了Binary Log Group Commit（BLGC）实现了组提交。
BLGC组提交简单的思想总结就是 将redo log和binlog 的过程进行拆分合并，首先将redo log和binlog原子化的进行到一个队列中，然后一起刷盘，最后一起提交。





 
