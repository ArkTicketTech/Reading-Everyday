# grokking streaming systems real-time event processing pp. 109-140

## ch4.Delivery semantics

- 引入交付语义及其影响
- 最多一次交付语义
- 至少一次交付语义
- 恰好一次交付语义

### Revisit the fraud detection job

欺诈检测任务有多个分析器并行工作来处理进入卡网络的交易。这些分析器的欺诈评分会发送到一个聚合器，以计算每笔交易的最终结果，然后将结果写入数据库供交易呈现器使用。20毫秒的延迟阈值至关重要。如果不能及时做出决定，交易呈现器将无法向银行提供交易的答案。理想情况下，希望任务能够顺利运行，并始终满足延迟要求。但是，事情总是会发生意外。

在分布式系统中，做出了许多权衡。任何流处理系统的一个挑战是可靠地处理事件。流处理框架可以帮助尽可能可靠地保持任务运行，但需要了解自己的真正需求。我们习惯于在计算机中看到准确的结果；因此，重要的是要理解，在流处理系统中准确性并不是绝对的。在必要时，可能需要牺牲准确性。

当系统正常运行时，结果会是准确的。然而，当系统的某个部分不可靠时，我们会选择低延迟而不是准确性，并接受不准确的部分结果。

### Partial result

![01](https://inasa.dev/img/grokkingstreamingsystems/ch5/01.png)

分数聚合器从所有分析器接收了T1和T3的分数，但缺少了T2的一个分数。由于不想错过截止时间，聚合器基于现有数据聚合分数，并将结果存储到数据库中。T1和T3的结果是准确的，但T2的结果是部分结果，准确性无法保证。

T2潜在的不准确部分结果比等待准确结果而错过20毫秒的截止时间更可取。

### New concepts: (The number of) times delivered and times processed

要理解交付语义的真正含义，处理次数和交付次数的概念将非常有帮助：

- 处理次数可以指一个事件被组件处理的次数
- 交付次数可以指一个组件生成结果的次数

### New concept: Delivery semantics

交付语义涉及流处理引擎如何保证流处理任务中事件的交付（或成功处理）。

- 至多一次（At-most-once）——流处理任务保证每个事件最多被处理一次，但不保证一定成功处理。
- 至少一次（At-least-once）——流处理任务保证每个事件至少成功处理一次，但不保证处理次数。
- 仅一次（Exactly-once）——流处理任务保证每个事件成功处理且仅处理一次（至少看起来是这样）。在某些框架中，这也被称为有效一次（effectively-once）。

![02](https://inasa.dev/img/grokkingstreamingsystems/ch5/02.png)

![03](https://inasa.dev/img/grokkingstreamingsystems/ch5/03.png)

### At-most-once

在具有这种语义的任务中，事件不会被跟踪。引擎将尽力成功处理每个事件，但如果过程中发生任何错误，引擎将忘记这些事件并继续处理其他事件。

![04](https://inasa.dev/img/grokkingstreamingsystems/ch5/04.png)

由于引擎不跟踪事件，整个任务可以非常高效地运行，而不会产生太多开销。而且，由于任务将继续运行，无需从问题中恢复，错误不会影响延迟和更高的吞吐量。此外，由于简单性，任务也更容易维护。另一方面，当系统出现问题时，丢失事件的影响是结果可能会暂时不准确。

### At-least-once

使用至少一次语义，流处理引擎将保证事件至少被处理一次。至少一次的一个副作用是，事件可能会被处理多次。

![05](https://inasa.dev/img/grokkingstreamingsystems/ch5/05.png)

### At-least-once with acknowledging

支持至少一次交付语义的一种典型方法是流处理任务中的每个组件都会确认其已经成功处理了一个事件或经历了失败。流处理框架通常会为你提供一个新的过程确认器（process acknowledger）来跟踪这些信息。这个确认器负责跟踪每个事件的当前和完成的处理过程。当所有处理过程完成，且没有当前处理的过程时，它会向数据源报告成功或失败的消息。

![06](https://inasa.dev/img/grokkingstreamingsystems/ch5/06.png)

在源组件发出一个事件后，它会首先将该事件保存在缓冲区中。在接收到确认器的成功消息后，它会将事件从缓冲区中移除，因为该事件已经成功处理。如果源组件接收到该事件的失败消息，它会通过将事件重新发出到任务中来重放该事件。

### Track early out events

需要考虑的最后一种情况是并非所有事件都会通过所有组件。有些事件可能会提前结束它们的处理流程。这也是为什么确认消息中的下游组件信息非常重要。例如，如果交易无效且不需要写入存储，系统使用分析器将是该事件的最后一站，处理将在那里完成。

![07](https://inasa.dev/img/grokkingstreamingsystems/ch5/07.png)

### New concept: Checkpointing

虽然确认机制在至少一次语义中工作良好，但它也有一些缺点：

- 需要实现确认逻辑（即代码更改）。
- 事件处理的顺序可能与输入不同，这可能会引发问题。例如，如果我们有三个事件[A, B, C]要处理，而在处理事件A时发生故障，源组件会稍后重放事件A的另一个副本，最终将四个事件[A（失败）, B, C, A]发送到任务中，并且事件A在B和C之后成功处理。

还有另一种支持至少一次语义的选项（如同所有分布式系统中的解决方案一样，这也有权衡）：检查点（checkpointing）。这是流处理系统中实现容错（即系统在发生故障后继续正常运行）的重要技术。

检查点在流处理系统中的应用

- 事件接收与处理：源组件发出事件，并开始处理。
- 创建检查点：在处理过程中，系统定期创建检查点，保存当前的处理状态。
- 处理故障恢复：
  - 如果系统在处理事件时发生故障，可以从最近的检查点恢复处理状态，继续处理未完成的事件，而不是从头开始。
  - 检查点保存了系统的当前状态，包括已经处理的事件和处理进度。
- 确保至少一次处理：通过从检查点恢复处理状态，确保每个事件至少被处理一次，即使系统发生故障。

### New concept: State

检查点是一段数据，通常保存在存储中，可以用于将实例恢复到之前的状态。

状态是每个实例内部在处理事件时发生变化的数据。例如，在系统使用任务中，每个系统使用分析器实例都会跟踪其处理的交易数量。这一计数在处理新交易时会发生变化，它是状态中的一部分信息。当实例重新启动时，需要恢复这个计数。

检查点与状态在流处理系统中的应用

- 事件处理与状态更新：实例接收事件并处理，同时更新内部状态数据（如处理的交易数量）。
- 创建检查点：系统定期创建检查点，保存当前状态数据。检查点保存在持久存储中，以便在发生故障时恢复。
- 故障恢复：
  - 当实例发生故障时，从最近的检查点恢复状态，确保事件处理的连续性。
  - 恢复的状态包括所有变化的数据，如交易计数。

总结

- 检查点：保存系统当前状态的数据，用于在故障时恢复。
- 状态：每个实例内部随事件处理而变化的数据。

### Checkpointing in the system usage job for the at-least-once semantic

需要引入一个有用的组件：事件日志（Event Log）

![08](https://inasa.dev/img/grokkingstreamingsystems/ch5/08.png)

事件日志是API网关和系统使用任务之间的一个队列，其中每个事件都带有一个偏移量（或时间戳）进行跟踪。读取器（或消费者）可以跳到特定的偏移量并从那里开始加载数据。

事件日志的工作原理

- 事件日志前置：在交易源组件之前引入一个事件日志，每分钟（或其他间隔时间）源实例会创建一个包含当前状态的检查点——即它正在处理的当前偏移量。
- 创建检查点：源实例保存当前状态，包括当前处理的偏移量。
- 重启后的恢复：当任务重启时，引擎将识别出实例应跳转到的正确偏移量（即回滚到上一个检查点），并从该点开始处理事件。

检查点和事件日志的示例流程

- 事件接收与记录：API网关接收事件并将其记录在事件日志中。
- 偏移量更新：源组件处理事件，并更新事件日志中的偏移量。
- 创建检查点：每隔一段时间，源组件创建一个检查点，保存当前偏移量和处理状态。
- 故障恢复：
  - 如果源组件发生故障并重启，引擎从最近的检查点恢复处理状态。
  - 源组件从检查点的偏移量开始重新处理事件。

### Checkpointing and state manipulation functions

- 定期创建检查点：每个源实例需要定期创建检查点，保存其当前状态。
- 保存检查点：检查点需要保存到一个（希望是容错的）存储系统中。
- 故障自动重启：检测到故障时，流处理任务需要自动重启。
- 恢复状态：任务需要识别最新的检查点，并且每个重启的源实例需要加载其检查点文件并恢复其先前的状态。
- 清理旧检查点：由于存储空间有限，需要清理旧的检查点以节省资源。

流处理任务的所有者只需关注一件事：状态（state）。更具体地说，有两个状态操作函数：

- 获取实例的当前状态：该函数将被定期调用。
- 使用从检查点加载的状态对象初始化实例：该函数将在流处理任务启动时调用。

### Exactly-once or effectively-once?

实现仅一次语义的关键点

- 状态一致性：确保在处理事件时，系统的状态是一致的，即使在发生故障时也能保持一致性。
- 事务性处理：在处理事件时，使用事务机制保证事件的处理是原子的，要么完全成功，要么完全失败。
- 去重机制：确保事件不会被重复处理，即使在重启或故障恢复时，也能识别并去重重复事件。

### Bonus concept: Idempotent operation

幂等操作，无论一个函数被给定一个数量多少次，输出总是相同的。换句话说，进行多次相同的调用与进行一次调用的效果相同。

### Exactly-once

仅一次语义是通过检查点（checkpointing）来支持的，这与至少一次的支持方式非常相似。不同之处在于，检查点不仅为源组件创建，还为操作符创建，以便在回滚时它们可以一起“穿越时间”。需要注意的是，只有有内部状态的操作符才需要检查点。对于没有内部状态的操作符，不需要检查点，因为在回滚期间没有任何需要恢复的内容。

### Comparing the delivery semantics again

![09](https://inasa.dev/img/grokkingstreamingsystems/ch5/09.png)

![10](https://inasa.dev/img/grokkingstreamingsystems/ch5/10.png)
