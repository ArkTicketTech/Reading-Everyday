## Dijkstra算法

「Dijkstra 算法」解决的是加权有向图「单源最短路径」问题，其中该图的所有权重必须为非负数。

一种贪心算法。





### [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

算法过程：



1. 建图及初始化。

    1. 构建带权图。
    2. 设置一个顶点到源点的最短距离是否「已确定」的 boolean数组`visited[]` ，下标表示顶点，`visited[v]`表示从源点`k`到`v`得最短距离已确定。
    3. 设置一个顶点到源点的最短距离数组 `distTo[] `，下标表示顶点，对于目前从源点不可达的顶点，距离都设置为无穷大。最开始源点到自身的最短距离为0，源点到其余所有的顶点都处于不可达状态，因此都设置为无穷大。

2. 从源点出发

    1. 寻找距离源点未确定最短距离的顶点u，找到后标记u已确定最短距离：visited[u] = true

    1. **松弛**u的邻接顶点：遍历u的所有邻接顶点v，并尝试松弛u -> v的边，更新源点到v的最短距离dv。

3. 循环2.1 - 2.2，直到所有的顶点都已经找到最短距离。



以一个循环寻找 当前距离未确定顶点中距离最小者 u ，立即置 u 的距离为「已确定」。



看Dijkstra算法，就是一种贪心的算法，不断寻找最短路径的顶点，数学上的证明：https://leetcode.cn/circle/discuss/jJQn7V/，但从直觉上去理解：

确定源点后，每次找到的都是距离源点**最近**的一个点作为下一个点开始标记访问和松弛，



比如上图，A是源点，第一轮确定C是最近的一个点，C就被立刻标记为「已访问」了，也就是说，C到A的「最小距离」已经是确定的了，**不会再有从其他路径来更短的距离了**，因为在路径权重都是非负数的情况下，如果还有更短的距离，就与最开始确定C是最近的一个点相互矛盾了，所以C可以大胆的被标记为「已访问」和确定最短距离。同时，与C相邻的D也会更新最短距离，就保证了接下来确定距源点最近的点的过程中，能够保证每一次选择最近点 都是正确的。



同理，在这个过程中，每次选取最短距离的时候，上一次的结果都是客观的，就导致下一次也一定是正确的。



不过Dijkstra算法 如上所述，只能适用于权重为非负数的图。一旦有负权重，就不能保证 **不会从其他路径来的更短距离了**。

代码就不贴了，太长了。


1. 朴素版在寻找到源点最短距离的顶点方法getMinDistanceToSource的复杂度为O(V)，寻找V个顶点，时间复杂度为O(V^2)。
2. 松弛顶点时，每次松弛的次数是u的邻接顶点个数 ，即出度。所有的松弛次数加起来就是边的数量，所以松弛的时间复杂度为O(E)
3. 总的时间复杂度为O(V^2 + E);
