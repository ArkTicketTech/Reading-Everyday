## bellman-ford算法

bellman-ford算法求加权有向图的最短路径，比dijkstra算法的优势在于：

1. 能够求带负权重的图；
2. 能够检测出图中是否存在负权环图；



有权有向图 - 权重为负数。



环的分类：

1. **正权环图**：环的总权和大于等于0
2. **负权环图**：环的总权重小于0



**定理一：在一个有 N 个顶点的「正权环图」中，两点之间的最短路径最多经过**`N-1`条边。

证明：显而易见



**定理二：「负权环」没有最短路径。**

证明：环的权重是负数，说明再走一圈回到原点后路径会变得更短，一直走圈圈证明了没有最短路径。

所以bellman-ford不能求带「负权环」的图。



### 动态规划基础版

Bellman-ford算法可以从动态规划的角度去理解：

比如求0 -> [0, 1, 2, 3]的最短路径的朴素的思路就是：

1. 求出0到达[0, 1, 2, 3]依次经过最多1、2、3... N条边的最短路径
2. 最后一次最多经过N条边的路径就是最短路径。



动态转移方程式：源点o到u的最短距离其实可以归纳为下面的公式：

```
dp[k][u] = min(dp[k-1][u], dp[k-1][v] + w(v, u))
```

1. `dp[k][u]`代表源点经历**最多**k条边到u的最短距离；
2. `dp[k - 1][u]` 代表源点最多经历k-1条边到v的最短距离，
3. `w(v, u)`指v到u的权重。



我们用动态规划表模拟一下：

源点设为0，横轴表示 源点0的目标顶点，纵轴表示源点最多经过N条边后到达目标顶点的最短距离。





实际上，dp矩阵的下一行只由上一行决定，因此实际上只需要两个数组就够了。

令`previous[u]`表示源点到u最多经历k-1条边到时候的最短距离，`current[u]`表示源点到u最多经历k条边到时候的最短距离。

`current[u] = min \{ previous[u], previous[v_i] + w(v_i, u) \}`



所以在空间上可以只使用两个一维数组就可以进行滚动计算。

#### 代码模版

不贴代码了。太长了

### SPFA

`bellman-ford`算法的优化版的缺陷：对边进行全量松弛时，是随机选择的边，具有很大的随机性，不同的边的选择会使得计算收敛的速度不一样。如果想尽早的收敛，我们希望所有的松弛都是有效松弛，也就是顶点所有入边的松弛是无遗漏且不重复的。



SPFA(Shortest Path Faster Algorithm) 是对BF算法的一种改进，「SPFA」算法是通过队列来维护我们接下来要遍历的起点，而不是「BF」算法中的任意还没有遍历过的边。每次只有当某个顶点的最短距离更新之后，并且该顶点不在「队列」中，我们就将该顶点加入到「队列」中。一直循环以上步骤，直到队列为空，就可以终止算法。

SPFA的核心在于 只有前驱结点有更新，邻接的结点才会去更新。



1. 建图及初始化
    1. 构建加权图
    2. 设置一个大小为｜V｜的`dists[]`，下标表示顶点。初始化所有顶点到源点s到距离为`infinity`，表示该顶点到源点的距离尚未确定
    3. 设置一个大小为`inCount[]`记录顶点的入队次数
    4. 设置一个队列queue
    5. `dists[s]=0`
    6. 源点入队
2. 遍历队列queu，队列不为空时
    1. 队头顶点u出队，松弛u得所有邻接边
    2. 判断是否有`du+|(u,v)| < dv`，若有进行松弛 `dv = du+|(u,v)|`
        1. 判断邻接顶点是否已经在队列中，没有则入队，如果入队次数超过了|V|-1次，那么就说明有环，可以提前终止算法，没有则`inCount[v]++`。
3. 寻找dists中最短路径



不贴代码了。太长了
