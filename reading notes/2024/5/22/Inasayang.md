# gotips pp. 222-end

## 71.⽤泛型让 sync.Pool 类型安全

- sync.Pool没有固定的⼤⼩
- 把对象放回池⼦后，需要忘掉它，它可能会被清除或GC
- 对象可能有状态，在放⼊池中之前或之后从池中检索时清除或者重置状态

```go
type Pool[T any] struct {
    internal *sync.Pool
}
func NewPool[T any](newF func() T) Pool[T] {
    return Pool[T]{
        internal: &sync.Pool{
            New: func() interface{} {
                return newF()
            },
        },
    }
}
```

## 72.使⽤strings.EqualFold进⾏忽略⼤⼩写的字符串⽐较

- 快速路径：快速检查 ASCII 字符，逐个字符查看每个字符
- 慢速路径：如果在任何字符串中发现 Unicode 字符，则切换到详细的 Unicode ⽐较

## 73.⽤stringer⼯具给枚举类型实现String()⽅法

```go
package main

// 定义 HeroType 枚举类型
type HeroType int

const (
    Warrior HeroType = iota
    Mage
    Archer
)
```

shell:

```shell
stringer -type=HeroType
```

```go
// Code generated by "stringer -type=HeroType"; DO NOT EDIT.
package main
import "strconv"
func _() {
    // An "invalid array index" compiler error signifies that the constant values have changed.
    // Re-run the stringer command to generate them again.
    var x [1]struct{}
    _ = x[Warrior-0]
    _ = x[Mage-1]
    _ = x[Archer-2]
}
const _HeroType_name = "WarriorMageArcher"
var _HeroType_index = [...]uint8{0, 7, 11, 17}
func (i HeroType) String() string {
    if i < 0 || i >= HeroType(len(_HeroType_index)-1) {
        return "HeroType(" + strconv.FormatInt(int64(i), 10) + ")"
    }
    return _HeroType_name[_HeroType_index[i]:_HeroType_index[i+1]]
}
```

```go
package main

import "fmt"

func main() {
    var hero HeroType = Mage
    fmt.Println(hero) // 输出：Mage
}
```

## 74.使 time.Duration 清晰易懂

略

## 75.使⽤singleflight优化多次调⽤

```go
func FetchExpensiveData() (int64, error) {
    time.Sleep(3 * time.Second)
    return time.Now().Unix() / 10, nil
}
```

只运⾏⼀次函数，⽆论在 3 秒钟内调⽤多少次，它都能返回
⼀个可靠的结果

```go
var group singleflight.Group

func FetchExpensiveData() (interface{}, error) {
 // Simulate fetching expensive data here
 return "some data", nil
}

func UsingSingleFlight(key string) {
 v, err, _ := group.Do(key, func() (interface{}, error) {
  return FetchExpensiveData()
 })
 if err != nil {
  fmt.Println("Error fetching data:", err)
  return
 }
 fmt.Println("Fetched data:", v)
}
```

group∙Do返回：（ result any, err error, shared bool ），其中的 " shared "（共享）部分⾮常简单，它只是表示结果是否在多次调⽤中共享

## 76.函数调⽤的结果回传

略

## 77.带缓冲的 channel 作为信号量来限制 goroutine 执⾏

```go
type Semaphore chan struct{}
// 创建新的信号量
func NewSemaphore(max int) Semaphore {
 return make(chan struct{}, max)
}
// 获取信号量
func (s Semaphore) Acquire() {
 s <- struct{}{}
}
// 释放信号量
func (s Semaphore) Release() {
 <-s
}
```

## 78.⾮阻塞 channel 发送技巧

```go
func (g *Group) TryGo(f func() error) bool {
    if g.sem != nil {
        select {
        case g.sem <- token{}:
            return true
        default:
            return false
        }
    }
    return false
}
```
