# 选择排序

一种最简单的排序思路是：

1. 首先找到数组中最小的那个元素；
2. 其次，将它与数组的第一个元素交换位置；
3. 再次，在剩下的元素中找到最小的元素，将它与数组中的第二个元素交换位置。
4. 如此反复，直到整个数组排序。

这个方法就叫做选择排序，因为它在不断地选择剩余元素之中的最小值。



比如`[2, 3, 3, 1]`

1. 第一个元素2跟3、3、1比较，1比2最小，交换2跟1，变成`[1, 3, 3, 2]`
2. 第二个元素3跟后面的3、2比较，2比3最小，交换2跟3，变成`[1, 2, 3, 3]`
3. 第三个元素3跟后面的3比，不需要交换。

这个思路还是很清晰的，每次比较选择最小的在前面，遍历完之后自然数组就是有序的。

这其中还有个比较重要的知识点，我们看第二步，第二个3跟2交换，于是第二个3跑到了第三个3后面去了，虽然他们是相等的，并不影响最后的结果，但是如果排序的内容是一个对象的多个属性，下一个属性是在上一个属性相等的情况下是有序的（比如MySQL中的联合索引），这样交换后就破坏了对象的这种有序性，因此我们也称这种排序是不稳定的排序。相比来说，冒泡排序并不会将两个等值的数字交换，因此冒泡排序则是稳定的排序。



```java
public class SelectionSort {
  // 升序
  public static void selectionSort(int[] arr) {
    for(int i = 0; i < arr.length; i++) {
      int minIndex = i;
      for(int j = i + 1; j < arr.length; j++) {
        if(arr[j] < arr[minIndex]) {
          minIndex = j;
        }
      }
      swap(arr, i, minIndex);
    }

    private static void swap(int[] arr, int i, int j) {
      int temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }
  }
}
```

算法特点：

1. 运行时间与输入无关
2. 数据移动为N次交换

时间复杂度：需要N^2/2次比较和N次交换。
