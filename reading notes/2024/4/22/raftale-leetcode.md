开始刷动态规划的题，最简单形式是单串：

单串 dp[i] 线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0..i]上，原问题的解，状态转移方程如下，dp[i]只依赖i-1之前的解：
dp[i]=f(dp[i-1],dp[i-2],...,dp[0])

其中 i 位置的处理，根据不同的问题，主要有两种方式：
1. 第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0..i]上，且取 i，原问题的解；
2. 第二种是 i 位置可以取可以不取
   大部分的问题，对 i 位置的处理是第一种方式。

经典的单串问题有：
1. 最大子数组和：53
2. 最长上升子序列 LIS：300
3. 不相邻子序列的最大和问题：打家劫舍系列
4. 单串变形，需要考虑两个位置的情况
   a. 有一些单串问题在涉及状态时需要考虑最后两位的情况，因为只考虑最后一个的话无法对状态描述清楚
   b. 最长的斐波那契子序列的长度：dp[i][j]:= 以 j, i 结尾，转移时在 [0..j] 中找满足条件的 k 这一步可以二分或哈希表
   c. 最长等差数列 —— dp[i][j]:= 以 j, i 结尾，转移时在 [0..j] 中找满足条件的 k 这一步用哈希表，键为数组值，值为保存下标的平衡树
5. 与二分、贪心、排序等算法结合：
   a. 形成字符串的最短路径 —— DP + 二分，贪心
   b. 最大整除子集 —— 先对数组排序
6. 带维度单串：子问题不仅与位置有关，还与某种指标k有关，k可以是长度、颜色等，通常写成dp[i][k]
   a. 256  dp[i][k] := 前i个房子刷成k颜色的最少成本
   b. 813 dp[i][j] := 前i个数被划分为j个子数组的最大平均值和
   c. 1186 dp[i][k] := 选出以i结尾的子数组，再删除k个后剩余的最大和
   d. 周赛353C：dp[i][k] := 前i个数，第i个位置选nums{k}[i]的子数组
