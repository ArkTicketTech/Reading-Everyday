类型推断是在给定类型系统内推理项类型的问题，如果存在类型的话。在我们之前考虑过的类型系统中，程序通常有丰富的类型注释。因此，类型推断问题通常只是在检查这些注释的一致性。这个问题并不总是很简单的，但在 $F_1$ 的类型系统中，我们可以找到简单的类型检查算法。

更难的问题称为**可类型化**(typability)或**类型重构**(type reconstruction), 即为一个未经类型注释的程序 $M$，找到一个环境 $\Gamma$，一个带有类型注释的版本 $M'$，以及一个类型 $A$，使得 $A$ 是环境 $\Gamma$ 中的 $M'$ 的类型。（一个带有类型注释的程序 $M'$ 去除所有类型注释后即还原为 $M$。）对于无类型的 λ-演算，可以通过在 ML 中使用的 Hindley-Milner 算法在 $F_1$ 中解决类型重构问题；此外，该算法能够为一个给定的 $F_1$ 中的 λ-项 生成唯一的类型表示。然而，在 $F_2$ 中，对于无类型的 λ-演算，类型重构问题则无法解决[32]。在具有子类型的系统中进行类型重构也仍然是一个较开放的问题，尽管一些特殊解决方案开始出现[1,10,13,24]。

在这里，我们会着重介绍一些代表性系统中的类型推断算法，包括：$F_1$、$F_2$ 和 $F_{2<:}$。前两个系统具有唯一类型属性(unique type property)：如果一个项有类型，那么它只有一个类型。在 $F_{2<:}$ 中，则不存在唯一类型，因为子类型规则的存在，每个项都拥有某个类型及其所有超类型。但是，存在最小类型属性(minimum type property)：如果一个项有一组类型，那么这一组类型在子类型顺序上有一个最小元素[8]。这个最小类型属性适用于 $F_{2<:}$ 和 $F_{1<:}$ 的许多常见扩展。但在引入了基本类型的自定义子类型时可能会失效。