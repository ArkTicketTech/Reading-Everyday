缓存模式有下面三种：

1. Cache Aside
2. Read/Write Through
3. Write Behind Cache

# Cache Aside更新模式

分为三步：

1. 失效：先从缓存获取对应数据，没有数据则从数据库获取，然后放到缓存中
2. 命中：从缓存获取数据，成功后直接返回
3. 更新：数据库更新时让缓存失效

总结就是两个动作：

1. 读数据库数据-然后写缓存
2. 更新数据库-然后让缓存失效

这是标准的设计模式，注意数据库更新时不是更新缓存，而是让缓存失效。

如果是更新缓存，动作为：

1. 读数据库数据-然后写缓存
2. 更新数据库-然后更新缓存

如果是更新缓存，因为更新数据库和更新缓存不是一个原子操作，那么可能两个并发写操作可能错位造成脏数据。

1. 线程A更新数据库为a
2. 线程B更新数据库为b
3. 线程B更新缓存为b
4. 线程A更新缓存为a

那么最后就造成了数据库为b，但缓存为a的情况。



所以缓存直接失效能避免这个问题，但也不能完全避免并发问题。比如：

1. 线程A获取数据，发现缓存失效，于是读数据库
2. 线程B更新数据库
3. 线程B使缓存失效
4. 线程A更新缓存

但上述发生的可能性非常低，需要的条件是：缓存失效和写操作同时发生，而且读操作需要比写操作慢，但实际上一般情况下读操作快于写操作。

所以这个并发问题的发生的概率相对前面的并发问题很低。



在实际中，缓存都是设置一个短暂的过期时间，有些应用场景没有必要也无需在更新数据库后让缓存失效，更进一步降低了复杂度。

# Read/Write Through 更新模式

Cache Aside 需要链接两个数据源，应用程的编码相对就比较复杂。如果应用程序只连接缓存服务，然后将逻辑封装在缓存服务中，应用层就不需要考虑写数据库了。

Read/Write Through就是这样一种策略：

1. Read Through读数据

1. 命中缓存，直接返回
2. 未命中，加载数据库到缓存并返回

1. Write Through写数据：

1. 命中缓存：更新缓存
2. 未命中：更新数据库

简化了应用层的编程，将复杂度进行了封装。

同时两个写操作、一写一读的并发操作都不会有并发问题；

适用场景是：

1. 需要频繁的读取数据；
2. 不能忍受数据丢失

# Write Behind Caching 更新模式

Write Behind Caching跟Read/Write Through的区别在于更新数据库时并不是实时更新，而是统一写入缓存，再由其他线程按一定频率或规则异步落盘到数据库。这个跟Linux 文件系统的Page cache的思想是一致的，当然因为读写都在缓存，所以极大的提高了读写的性能。

但缺点是数据还没有落盘时宕机，存在数据丢失的风险。



如果不能忍受数据丢失，选择Read/Write Through更合适；

如果追求性能，数据丢失不重要，选择Write Behind Caching更合适。

业务编码中，还是第一种Cache Aside使用的比较多，主要是简单易懂易操作。

# 缓存设计的重点

缓存主流都是用的redis。

本地缓存的不足：

1. 每台机器的内存不够大
2. 本地缓存使得服务有状态，有些场景违背了无状态的微服务设计

所以分布式缓存都是一个集群，保证内存够大，带宽够大。

缓存的要义对热点数据的查询性能提升。
