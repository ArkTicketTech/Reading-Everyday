# Cache Aside更新模式

三步：

1. 失效：先从缓存获取对应数据，没有数据则从数据库获取，然后放到缓存中
2. 命中：从缓存获取数据，成功后直接返回
3. 更新：数据库更新时让缓存失效

总结就是两个动作：

1. 读数据库数据-然后写缓存
2. 更新数据库-然后让缓存失效

这是标准的设计模式，注意数据库更新时不是更新缓存，而是让缓存失效。

如果是更新缓存，因为更新数据库和更新缓存不是一个原子操作，那么可能两个并发的更新操作可能错位造成脏数据。



即使是使得缓存失效，也不是完全没有并发问题。比如：

1. 线程A获取数据，发现缓存失效，于是读数据库
2. 线程B更新数据库
3. 线程B使缓存失效
4. 线程A更新缓存

但上述发生的可能性非常低，需要的条件是：缓存失效和写操作同时发生，而且读操作需要比写操作慢，但实际上一般情况下读操作快于写操作。

所以这个并发问题的概率是非常低的。



在实际中，缓存都是设置一个短暂的过期时间，没有必要也无需在更新数据库后让缓存失效，更进一步降低了复杂度。



# Read/Write Through 更新模式

应用程序只连接缓存服务，然后由缓存服务代理更新数据库。

Read Through 查询中更新缓存

Write Through 写入缓存时如果命中缓存，直接修改缓存，然后由Cache自己更新数据库，没有命中则更新数据库

唯一的好处是简化了应用层的编程，将复杂度封装在了Cache中。

# Write Behind Caching 更新模式

更新数据的时候，只更新缓存，然后异步刷新数据库。这个跟Linux 文件系统的Page cache类似。

缺点是数据可能丢失，优点是性能高。



# 缓存设计的重点

缓存主流都是用的redis。

本地缓存的不足：

1. 每台机器的内存不够大
2. 本地缓存使得服务有状态，有些场景违背了无状态的微服务设计

所以分布式缓存都是一个集群，保证内存够大，带宽够大。

缓存的要义对热点数据的查询性能提升。
